#!/usr/bin/env python3
"""
Code generator for Archipelago item definitions.
Reads apitems.yml and generates C++ code for item handling.
"""

import yaml
import sys
import subprocess
from pathlib import Path
from typing import List, Dict, Any

def format_file_with_clang_format(file_path: Path, project_root: Path) -> bool:
    """Format a file using clang-format with the project's configuration."""
    try:
        # Run clang-format in-place with the project's .clang-format file
        result = subprocess.run([
            "clang-format", 
            "-i",  # in-place
            "--style=file",  # use .clang-format file
            str(file_path)
        ], 
        cwd=project_root,  # Run from project root to find .clang-format
        capture_output=True, 
        text=True,
        timeout=30
        )
        
        if result.returncode != 0:
            print(f"Warning: clang-format failed for {file_path}: {result.stderr}")
            return False
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError) as e:
        print(f"Warning: Could not run clang-format on {file_path}: {e}")
        return False

def generate_header(items: List[Dict[str, Any]]) -> str:
    """Generate the C++ header file content."""

    # Collect unique accessor names from event_flags items
    accessors_used = set()
    for item in items:
        if item['type'] == 'event_flags':
            for flag in item.get('flags', []):
                accessors_used.add(flag['accessor'])

    header = """#pragma once
// Auto-generated by scripts/generate_apitems.py
// Do not edit manually - regenerate by modifying src/okami-apclient/apitems.yml

#include <unordered_map>
#include <cstdint>
#include <string>

namespace apitems
{

// Item handler types
enum class ItemHandlerType
{
    Brush,                // Regular brush technique
    ProgressiveBrush,     // Power Slash / Cherry Bomb with upgrades
    Inventory,            // Direct inventory item
    EventFlags,           // Sets game state flags
    Progressive,          // Progressive weapons
};

// Flag information for event_flags items
struct FlagInfo
{
    const char* accessor_name;  // Name of accessor in apgame namespace
    unsigned int bit;           // Bit index to set
};

// Item definition structure
struct APItemDef
{
    int id;
    const char* name;
    ItemHandlerType type;

    // Type-specific data
    union
    {
        // For Brush type
        struct
        {
            int brush_index;
        } brush;

        // For ProgressiveBrush type
        struct
        {
            int brush_index;
            const unsigned int* upgrade_bits;
            size_t upgrade_count;
        } progressive_brush;

        // For Inventory type
        struct
        {
            int item_id;
        } inventory;

        // For EventFlags type
        struct
        {
            const FlagInfo* flags;
            size_t flag_count;
        } event;

        // For Progressive type
        struct
        {
            const int* stages;
            size_t stage_count;
        } progressive;
    };
};

// Global item registry
extern const std::unordered_map<int, const APItemDef*> item_registry;

// Lookup item by ID
const APItemDef* findItem(int id);

} // namespace apitems
"""

    return header


def generate_implementation(items: List[Dict[str, Any]]) -> str:
    """Generate the C++ implementation file content."""

    impl = """#include "apitems_generated.hpp"

namespace apitems
{

"""

    # Generate static data for each item type

    # Generate flag arrays for event_flags items
    flag_arrays = []
    for item in items:
        if item['type'] == 'event_flags':
            flags = item.get('flags', [])
            if flags:
                array_name = f"flags_{item['name'].replace(' ', '_').replace('-', '_')}"
                impl += f"static const FlagInfo {array_name}[] = {{\n"
                for flag in flags:
                    impl += f"    {{\"{flag['accessor']}\", {flag['bit']}}},\n"
                impl += "};\n\n"
                flag_arrays.append((item['id'], array_name, len(flags)))

    # Generate upgrade bit arrays for progressive_brush items
    upgrade_arrays = []
    for item in items:
        if item['type'] == 'progressive_brush':
            upgrades = item.get('upgrade_bits', [])
            if upgrades:
                array_name = f"upgrades_{item['name'].replace(' ', '_').replace('-', '_')}"
                impl += f"static const unsigned int {array_name}[] = {{ {', '.join(str(u) for u in upgrades)} }};\n"
                upgrade_arrays.append((item['id'], array_name, len(upgrades)))

    if upgrade_arrays:
        impl += "\n"

    # Generate stage arrays for progressive items
    stage_arrays = []
    for item in items:
        if item['type'] == 'progressive':
            stages = item.get('stages', [])
            if stages:
                array_name = f"stages_{item['name'].replace(' ', '_').replace('-', '_')}"
                impl += f"static const int {array_name}[] = {{ {', '.join(f'0x{s:02X}' for s in stages)} }};\n"
                stage_arrays.append((item['id'], array_name, len(stages)))

    if stage_arrays:
        impl += "\n"

    # Generate item definition array
    impl += "// Item definitions\n"
    impl += "static const APItemDef item_defs[] = {\n"

    for item in items:
        impl += f"    // {item['name']}\n"
        impl += "    {\n"
        impl += f"        .id = 0x{item['id']:X},\n"
        impl += f"        .name = \"{item['name']}\",\n"
        impl += f"        .type = ItemHandlerType::{item['type'].title().replace('_', '')},\n"

        # Type-specific union data
        if item['type'] == 'brush':
            impl += f"        .brush = {{ .brush_index = {item['brush_index']} }},\n"

        elif item['type'] == 'progressive_brush':
            array_info = next((a for a in upgrade_arrays if a[0] == item['id']), None)
            if array_info:
                impl += f"        .progressive_brush = {{\n"
                impl += f"            .brush_index = {item['brush_index']},\n"
                impl += f"            .upgrade_bits = {array_info[1]},\n"
                impl += f"            .upgrade_count = {array_info[2]}\n"
                impl += "        },\n"
            else:
                impl += f"        .progressive_brush = {{ .brush_index = {item['brush_index']}, .upgrade_bits = nullptr, .upgrade_count = 0 }},\n"

        elif item['type'] == 'inventory':
            impl += f"        .inventory = {{ .item_id = 0x{item['item_id']:X} }},\n"

        elif item['type'] == 'event_flags':
            array_info = next((a for a in flag_arrays if a[0] == item['id']), None)
            if array_info:
                impl += f"        .event = {{ .flags = {array_info[1]}, .flag_count = {array_info[2]} }},\n"
            else:
                impl += "        .event = { .flags = nullptr, .flag_count = 0 },\n"

        elif item['type'] == 'progressive':
            array_info = next((a for a in stage_arrays if a[0] == item['id']), None)
            if array_info:
                impl += f"        .progressive = {{ .stages = {array_info[1]}, .stage_count = {array_info[2]} }},\n"
            else:
                impl += "        .progressive = { .stages = nullptr, .stage_count = 0 },\n"

        impl += "    },\n"

    impl += "};\n\n"

    # Generate lookup map
    impl += "// Item lookup registry\n"
    impl += "const std::unordered_map<int, const APItemDef*> item_registry = {\n"
    for i, item in enumerate(items):
        impl += f"    {{0x{item['id']:X}, &item_defs[{i}]}},\n"
    impl += "};\n\n"

    # Generate lookup function
    impl += """const APItemDef* findItem(int id)
{
    auto it = item_registry.find(id);
    if (it != item_registry.end())
    {
        return it->second;
    }
    return nullptr;
}

} // namespace apitems
"""

    return impl


def main():
    if len(sys.argv) < 4:
        print("Usage: generate_apitems.py <input.yml> <output.hpp> <output.cpp>")
        sys.exit(1)

    input_path = Path(sys.argv[1])
    output_header = Path(sys.argv[2])
    output_impl = Path(sys.argv[3])

    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    # Read YAML
    with open(input_path, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)

    items = data.get('items', [])

    if not items:
        print("Warning: No items found in YAML file")
        sys.exit(1)

    # Generate code
    header_content = generate_header(items)
    impl_content = generate_implementation(items)

    # Write output files
    output_header.parent.mkdir(parents=True, exist_ok=True)
    output_impl.parent.mkdir(parents=True, exist_ok=True)

    with open(output_header, 'w', encoding='utf-8') as f:
        f.write(header_content)

    with open(output_impl, 'w', encoding='utf-8') as f:
        f.write(impl_content)

    format_file_with_clang_format(output_header, project_root)
    format_file_with_clang_format(output_impl, project_root)

    print(f"Generated {len(items)} item definitions")
    print(f"  Header: {output_header}")
    print(f"  Implementation: {output_impl}")


if __name__ == '__main__':
    main()
